(define (size vector) (vector-length vector))
(define (reduce-sum vector)
    (vector-fold (lambda (index summation x) (+ summation x)) 0 vector))
(define (elementwise-square vector)
    (define (square i x) (* x x))
    (vector-map square vector))
(define (elementwise-add vector-1 vector-2)
    (vector-map (lambda (i x y) (+ x y) vector-1 vector-2)))
(define (scalar-product scalar vector)
    (define (prod-s i x) (* scalar x)
    (vector-map prod-s vector)))

(define (make-state p q) (cons p q))
(define (get-p state) (car state))
(define (get-q state) (cdr state))

(define (K p) (* 0.5 (reduce-sum (elementwise-square p))))
(define (sample-p size)
    (define (sample i x) (- 1 (random-uniform 2)))
    (define ones (vector size 1))
    (vector-map sample ones))

(define (HMC U grad-U epsilon L current-q)
    (define (q+dq p q dt)
        (elementwise-add q (scalar-product epsilon p)))
    (define (p+dp/2 p q)
        (elementwise-add p (scalar-product (* -0.5 epsilon) (grad-U q))))
    (define (leap-frog i state)
        (let ((p (get-p state))
              (q (get-q state)))
             (if (eq? i L)
                 (make-pair p q)
                 (let ((half-p p+dp/2 p q)
                       (next-q q+dq half-p q)
                       (next-p p+dp half-p next-q))
                       (leap-frog (+ i 1) (make-state next-p next-q))))))
    (define (energy-diff current-state proposed-state)
        (let ((current-K (K (get-p current-state)))
              (current-U (U (get-q current-state)))
              (proposed-K (K (get-p proposed-state)))
              (proposed-U (U (get-q proposed-state))))
              (+ current-K current-U (* -1 proposed-K) (* -1 proposed-U))))

    (let ((current-state (sample-p (size current-q)) current-q))
         (let ((proposed-state (leap-frog 1 current-state)))
              (if (< (uniform-random 1)
                     (energy-diff current-state proposed-state))
                  (get-q proposed-state)
                  (get-q current-state)))))
